// ignore_for_file: avoid_dynamic_calls

import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:http/http.dart' as http;
import 'package:mime/mime.dart';

/// Extension methods for [Iterable<Part>].
extension ContentExtension on Iterable<Part> {
  /// Creates a [Iterable<Part>] with a single [TextPart] containing the given
  /// [text].
  static Iterable<Part> text(String text) => [TextPart(text)];
}

/// Enum representing the role of a message in a conversation.
enum MessageRole {
  /// Instructions or context for the conversation.
  system,

  /// Messages from the end user.
  user,

  /// Messages generated by the AI model.
  model,
}

/// Enum to distinguish between tool call and tool result parts.
enum ToolPartKind {
  /// A tool call.
  call,

  /// A tool result.
  result,
}

/// Represents a message in a conversation, consisting of a role and a list of
/// content parts.
///
/// Each message has a [role] (system, user, or model) and a [parts] list,
/// where each item is a [Part] (e.g., text, media, or tool call).
class Message {
  /// Creates a [Message] with the given [role] and [parts] parts.
  Message({required this.role, required this.parts});

  /// Creates a [Message] from a raw JSON string.
  factory Message.fromRawJson(String str) => Message.fromJson(json.decode(str));

  /// Creates a [Message] from a JSON map.
  factory Message.fromJson(Map<String, dynamic> json) => Message(
    role: MessageRole.values.byName(json['role']),
    parts:
        json['parts'] == null
            ? []
            : List<Part>.from(json['parts']!.map((x) => Part.fromJson(x))),
  );

  /// Creates a system message with the given [parts].
  Message.system(Iterable<Part> parts)
    : this(role: MessageRole.system, parts: parts);

  /// Creates a user message with the given [parts].
  Message.user(Iterable<Part> parts)
    : this(role: MessageRole.user, parts: parts);

  /// Creates a model message with the given [parts].
  Message.model(Iterable<Part> parts)
    : this(role: MessageRole.model, parts: parts);

  /// The role of the message (system, user, or model).
  final MessageRole role;

  /// The list of content parts in the message.
  final Iterable<Part> parts;

  /// Returns a copy of this message with optional new [role] and/or [parts].
  Message copyWith({MessageRole? role, Iterable<Part>? parts}) =>
      Message(role: role ?? this.role, parts: parts ?? this.parts);

  /// Converts this message to a raw JSON string.
  String toRawJson() => json.encode(toJson());

  /// Converts this message to a JSON map.
  Map<String, dynamic> toJson() => {
    'role': role.name,
    'parts': List<dynamic>.from(parts.map((x) => x.toJson())),
  };

  /// Returns a concatenated string of all text parts in this message.
  String get text => parts.whereType<TextPart>().map((p) => p.text).join();

  @override
  String toString() => 'Message(role: $role, parts: $parts)';
}

/// An abstract base class for a part of a message's content.
///
/// Subclasses include [TextPart], [DataPart], and [ToolPart].
sealed class Part {
  /// Base constructor for [Part].
  const Part();

  /// Creates a [Part] from a JSON map.
  ///
  /// The type of part is determined by the keys present in the map.
  factory Part.fromJson(Map<String, dynamic> json) {
    if (json.containsKey('text')) {
      return TextPart.fromJson(json);
    } else if (json.containsKey('data')) {
      return DataPart.fromJson(json);
    } else if (json.containsKey('tool')) {
      return ToolPart.fromJson(json);
    } else {
      throw Exception('Unknown part type: $json');
    }
  }

  /// Converts this part to a JSON map.
  Map<String, dynamic> toJson();
}

/// A text part of a message's content.
class TextPart extends Part {
  /// Creates a [TextPart] with the given [text].
  const TextPart(this.text);

  /// Creates a [TextPart] from a JSON map.
  factory TextPart.fromJson(Map<String, dynamic> json) =>
      TextPart(json['text']);

  /// The text content of this part.
  final String text;

  @override
  Map<String, dynamic> toJson() => {'text': text};

  @override
  String toString() => 'TextPart($text)';
}

const _defaultMimeType = 'application/octet-stream';
String _mimeType(String path) => lookupMimeType(path) ?? _defaultMimeType;
String _nameFromMimeType(String mimeType) =>
    mimeType.startsWith('image/')
        ? 'image.${mimeType.split('/').last}'
        : 'file.${mimeType.split('/').last}';

/// Extracts the name from a URL.
/// for example:
/// - https://example.com/image -> image
/// - https://example.com/image.png -> image.png
/// - https://example.com/image.jpg?name=test -> image.jpg
/// - https://example.com/image.jpg?name=test.png -> image.jpg
/// - https://example.com/ -> example.com
String _nameFromUrl(String url) {
  final uri = Uri.parse(url);
  return uri.pathSegments.isNotEmpty ? uri.pathSegments.last : '';
}

/// A data part of a message's content, such as an image or video.
class DataPart extends Part {
  /// Creates a [DataPart] with the given [mimeType] and [url].
  DataPart(this.bytes, {required this.mimeType, String? name})
    : assert(mimeType.isNotEmpty, 'DataPart mimeType must not be empty'),
      assert(bytes.isNotEmpty, 'DataPart bytes must not be empty'),
      name = name ?? _nameFromMimeType(mimeType);

  /// Creates a [DataPart] from a JSON map.
  factory DataPart.fromJson(Map<String, dynamic> json) {
    final data = json['data'] as Map<String, dynamic>?;
    final mimeType = data?['mimeType'] as String? ?? _defaultMimeType;
    final bytes = base64Decode((data?['data'] as String?) ?? '');
    return DataPart(bytes, mimeType: mimeType);
  }

  /// Creates a [DataPart] from a URL.
  static Future<DataPart> url(Uri url) async {
    final data = url.data;
    final mimeType = data != null ? data.mimeType : _mimeType(url.toString());
    final bytes = data?.contentAsBytes() ?? (await http.get(url)).bodyBytes;
    return DataPart(bytes, mimeType: mimeType);
  }

  /// The MIME type of the media (e.g., 'image/jpeg').
  final String mimeType;

  /// The data of the media.
  final Uint8List bytes;

  /// The name of the data part.
  final String name;

  @override
  Map<String, dynamic> toJson() => {
    'data': {'mimeType': mimeType, 'data': base64Encode(bytes)},
  };

  @override
  String toString() => 'DataPart($mimeType, ${bytes.take(32)}...)';

  /// Creates a [DataPart] from a file.
  static Future<DataPart> file(File file) async {
    final mimeType = _mimeType(file.path);
    final bytes = await file.readAsBytes();
    return DataPart(bytes, mimeType: mimeType);
  }
}

/// A link part of a message's content, representing a URL.
class LinkPart extends Part {
  /// Creates a [LinkPart] with the given [url].
  LinkPart(this.url, {String? mimeType, String? name})
    : assert(url.isAbsolute, 'LinkPart url must be absolute'),
      mimeType = mimeType ?? _mimeType(url.toString()),
      name = name ?? _nameFromUrl(url.toString());

  /// The URL of the link.
  final Uri url;

  /// The MIME type of the content at the URL.
  final String mimeType;

  /// The name of the link part.
  final String name;

  @override
  Map<String, dynamic> toJson() => {
    'url': url.toString(),
    'mimeType': mimeType,
  };

  @override
  String toString() => 'LinkPart($url)';
}

/// A tool call part of a message's content, representing a call to an external
/// tool or function.
class ToolPart extends Part {
  /// Creates a [ToolPart] with the given tool call or result details.
  ToolPart({
    required this.kind,
    required this.id,
    required this.name,
    this.arguments = const {},
    this.result = const {},
  }) : assert(id.isNotEmpty, 'ToolPart id must not be empty'),
       assert(name.isNotEmpty, 'ToolPart name must not be empty');

  /// Creates a [ToolPart] from a JSON map.
  factory ToolPart.fromJson(Map<String, dynamic> json) {
    final tool = json['tool'] as Map<String, dynamic>?;
    final hasResult = tool?['result'] != null;
    final kind = hasResult ? ToolPartKind.result : ToolPartKind.call;
    final id = tool?['id'] as String? ?? '';
    final name = tool?['name'] as String? ?? '';
    var arguments = <String, dynamic>{};
    if (tool != null && tool['arguments'] is Map) {
      arguments = Map<String, dynamic>.from(tool['arguments'] as Map);
    }
    var result = <String, dynamic>{};
    if (tool != null && tool['result'] is Map) {
      result = Map<String, dynamic>.from(tool['result'] as Map);
    }
    assert(id.isNotEmpty, 'ToolPart id must not be null or empty (fromJson)');
    assert(
      name.isNotEmpty,
      'ToolPart name must not be null or empty (fromJson)',
    );
    return ToolPart(
      kind: kind,
      id: id,
      name: name,
      arguments: arguments,
      result: result,
    );
  }

  /// Creates a tool call [ToolPart] with the given [id], [name], and
  /// [arguments].
  ToolPart.call({
    required String id,
    required String name,
    Map<String, dynamic> arguments = const {},
  }) : this(kind: ToolPartKind.call, id: id, name: name, arguments: arguments);

  /// Creates a tool result [ToolPart] with the given [id], [name], and
  /// [result].
  ToolPart.result({
    required String id,
    required String name,
    Map<String, dynamic> result = const {},
  }) : this(kind: ToolPartKind.result, id: id, name: name, result: result);

  /// The kind of tool part: call or result.
  final ToolPartKind kind;

  /// The unique identifier for the tool call.
  final String id;

  /// The name of the tool being called.
  final String name;

  /// The arguments passed to the tool (for calls).
  final Map<String, dynamic> arguments;

  /// The result returned from the tool call (for results).
  final Map<String, dynamic> result;

  @override
  Map<String, dynamic> toJson() => {
    'tool': {
      'kind': kind.name,
      'id': id,
      'name': name,
      'arguments': arguments,
      'result': result,
    },
  };

  @override
  String toString() => switch (kind) {
    ToolPartKind.call =>
      'ToolPart.call(id: $id, name: $name, args: $arguments)',
    ToolPartKind.result =>
      'ToolPart.result(id: $id, name: $name, result: $result)',
  };
}
