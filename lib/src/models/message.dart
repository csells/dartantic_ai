// ignore_for_file: avoid_dynamic_calls

import 'dart:convert';

/// Type alias for a list of content parts.
typedef Content = List<Part>;

/// Enum representing the role of a message in a conversation.
enum MessageRole {
  /// Instructions or context for the conversation.
  system,

  /// Messages from the end user.
  user,

  /// Messages generated by the AI model.
  model,
}

/// Enum to distinguish between tool call and tool result parts.
enum ToolPartKind {
  /// A tool call.
  call,

  /// A tool result.
  result,
}

/// Represents a message in a conversation, consisting of a role and a list of
/// content parts.
///
/// Each message has a [role] (system, user, or model) and a [content] list,
/// where each item is a [Part] (e.g., text, media, or tool call).
class Message {
  /// Creates a [Message] with the given [role] and [content] parts.
  Message({required this.role, required this.content});

  /// Creates a [Message] from a raw JSON string.
  factory Message.fromRawJson(String str) => Message.fromJson(json.decode(str));

  /// Creates a [Message] from a JSON map.
  factory Message.fromJson(Map<String, dynamic> json) => Message(
    role: MessageRole.values.byName(json['role']),
    content:
        json['content'] == null
            ? []
            : Content.from(json['content']!.map((x) => Part.fromJson(x))),
  );

  /// Creates a system message with the given [content].
  Message.system(Content content)
      : this(role: MessageRole.system, content: content);

  /// Creates a user message with the given [content].
  Message.user(Content content)
      : this(role: MessageRole.user, content: content);

  /// Creates a model message with the given [content].
  Message.model(Content content)
      : this(role: MessageRole.model, content: content);

  /// The role of the message (system, user, or model).
  final MessageRole role;

  /// The list of content parts in the message.
  final Content content;

  /// Returns a copy of this message with optional new [role] and/or [content].
  Message copyWith({MessageRole? role, Content? content}) =>
      Message(role: role ?? this.role, content: content ?? this.content);

  /// Converts this message to a raw JSON string.
  String toRawJson() => json.encode(toJson());

  /// Converts this message to a JSON map.
  Map<String, dynamic> toJson() => {
    'role': role.name,
    'content': List<dynamic>.from(content.map((x) => x.toJson())),
  };
}

/// An abstract base class for a part of a message's content.
///
/// Subclasses include [TextPart], [MediaPart], and [ToolPart].
abstract class Part {
  /// Base constructor for [Part].
  const Part();

  /// Creates a [Part] from a JSON map.
  ///
  /// The type of part is determined by the keys present in the map.
  factory Part.fromJson(Map<String, dynamic> json) {
    if (json.containsKey('text')) {
      return TextPart.fromJson(json);
    } else if (json.containsKey('media')) {
      return MediaPart.fromJson(json);
    } else if (json.containsKey('tool')) {
      return ToolPart.fromJson(json);
    } else {
      throw Exception('Unknown part type: $json');
    }
  }

  /// Converts this part to a JSON map.
  Map<String, dynamic> toJson();
}

/// A text part of a message's content.
class TextPart extends Part {
  /// Creates a [TextPart] with the given [text].
  const TextPart(this.text);

  /// Creates a [TextPart] from a JSON map.
  factory TextPart.fromJson(Map<String, dynamic> json) =>
      TextPart(json['text']);

  /// The text content of this part.
  final String text;

  @override
  Map<String, dynamic> toJson() => {'text': text};

  @override
  String toString() => 'TextPart(text: "$text")';
}

/// A media part of a message's content, such as an image or video.
class MediaPart extends Part {
  /// Creates a [MediaPart] with the given [contentType] and [url].
  MediaPart({required this.contentType, required this.url})
    : assert(contentType.isNotEmpty, 'MediaPart contentType must not be empty'),
      assert(url.isNotEmpty, 'MediaPart url must not be empty');

  /// Creates a [MediaPart] from a JSON map.
  factory MediaPart.fromJson(Map<String, dynamic> json) {
    final media = json['media'] as Map<String, dynamic>?;
    final contentType = media?['contentType'] as String? ?? '';
    final url = media?['url'] as String? ?? '';
    assert(
      contentType.isNotEmpty,
      'MediaPart contentType must not be empty (fromJson)',
    );
    assert(url.isNotEmpty, 'MediaPart url must not be empty (fromJson)');
    return MediaPart(contentType: contentType, url: url);
  }

  /// The MIME type of the media (e.g., 'image/jpeg').
  final String contentType;

  /// The URL or data URI of the media.
  final String url;

  @override
  Map<String, dynamic> toJson() => {
    'media': {'contentType': contentType, 'url': url},
  };

  @override
  String toString() => 'MediaPart(contentType: $contentType, url: $url)';
}

/// A tool call part of a message's content, representing a call to an external
/// tool or function.
class ToolPart extends Part {
  /// Creates a [ToolPart] with the given tool call or result details.
  ToolPart({
    required this.kind,
    required this.id,
    required this.name,
    this.arguments = const {},
    this.result = const {},
  }) : assert(id.isNotEmpty, 'ToolPart id must not be empty'),
       assert(name.isNotEmpty, 'ToolPart name must not be empty');

  /// Creates a [ToolPart] from a JSON map.
  factory ToolPart.fromJson(Map<String, dynamic> json) {
    final tool = json['tool'] as Map<String, dynamic>?;
    final hasResult = tool?['result'] != null;
    final kind = hasResult ? ToolPartKind.result : ToolPartKind.call;
    final id = tool?['id'] as String? ?? '';
    final name = tool?['name'] as String? ?? '';
    var arguments = <String, dynamic>{};
    if (tool != null && tool['arguments'] is Map) {
      arguments = Map<String, dynamic>.from(tool['arguments'] as Map);
    }
    var result = <String, dynamic>{};
    if (tool != null && tool['result'] is Map) {
      result = Map<String, dynamic>.from(tool['result'] as Map);
    }
    assert(id.isNotEmpty, 'ToolPart id must not be null or empty (fromJson)');
    assert(
      name.isNotEmpty,
      'ToolPart name must not be null or empty (fromJson)',
    );
    return ToolPart(
      kind: kind,
      id: id,
      name: name,
      arguments: arguments,
      result: result,
    );
  }

  /// Creates a tool call [ToolPart] with the given [id], [name], and 
  /// [arguments].
  ToolPart.call({
    required String id,
    required String name,
    Map<String, dynamic> arguments = const {},
  }) : this(
          kind: ToolPartKind.call,
          id: id,
          name: name,
          arguments: arguments,
        );

  /// Creates a tool result [ToolPart] with the given [id], [name], and 
  /// [result].
  ToolPart.result({
    required String id,
    required String name,
    Map<String, dynamic> result = const {},
  }) : this(
          kind: ToolPartKind.result,
          id: id,
          name: name,
          result: result,
        );

  /// The kind of tool part: call or result.
  final ToolPartKind kind;

  /// The unique identifier for the tool call.
  final String id;

  /// The name of the tool being called.
  final String name;

  /// The arguments passed to the tool (for calls).
  final Map<String, dynamic> arguments;

  /// The result returned from the tool call (for results).
  final Map<String, dynamic> result;

  @override
  Map<String, dynamic> toJson() => {
    'tool': {
      'kind': kind.name,
      'id': id,
      'name': name,
      'arguments': arguments,
      'result': result,
    },
  };

  @override
  String toString() => switch (kind) {
    ToolPartKind.call =>
      'ToolPart(kind: call, id: $id, name: $name, '
          'arguments: $arguments)',
    ToolPartKind.result =>
      'ToolPart(kind: result, id: $id, name: $name, result: $result)',
  };
}

/// Extension methods for [Content].
extension ContentExtension on Content {
  /// Creates a [Content] with a single [TextPart] containing the given [text].
  static Content text(String text) => [TextPart(text)];
}
