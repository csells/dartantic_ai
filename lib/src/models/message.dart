// ignore_for_file: avoid_dynamic_calls

import 'dart:convert';

/// Enum representing the role of a message in a conversation.
enum MessageRole {
  /// Instructions or context for the conversation.
  system,

  /// Messages from the end user.
  user,

  /// Messages generated by the AI model.
  model,
}

/// Represents a message in a conversation, consisting of a role and a list of
/// content parts.
///
/// Each message has a [role] (system, user, or model) and a [content] list,
/// where each item is a [Part] (e.g., text, media, or tool call).
class Message {
  /// Creates a [Message] with the given [role] and [content] parts.
  Message({required this.role, required this.content});

  /// Creates a [Message] from a raw JSON string.
  factory Message.fromRawJson(String str) => Message.fromJson(json.decode(str));

  /// Creates a [Message] from a JSON map.
  factory Message.fromJson(Map<String, dynamic> json) => Message(
    role: MessageRole.values.byName(json['role']),
    content:
        json['content'] == null
            ? []
            : List<Part>.from(json['content']!.map((x) => Part.fromJson(x))),
  );

  /// The role of the message (system, user, or model).
  final MessageRole role;

  /// The list of content parts in the message.
  final List<Part> content;

  /// Returns a copy of this message with optional new [role] and/or [content].
  Message copyWith({MessageRole? role, List<Part>? content}) =>
      Message(role: role ?? this.role, content: content ?? this.content);

  /// Converts this message to a raw JSON string.
  String toRawJson() => json.encode(toJson());

  /// Converts this message to a JSON map.
  Map<String, dynamic> toJson() => {
    'role': role.name,
    'content': List<dynamic>.from(content.map((x) => x.toJson())),
  };
}

/// An abstract base class for a part of a message's content.
///
/// Subclasses include [TextPart], [MediaPart], and [ToolPart].
abstract class Part {
  /// Base constructor for [Part].
  const Part();

  /// Creates a [Part] from a JSON map.
  ///
  /// The type of part is determined by the keys present in the map.
  factory Part.fromJson(Map<String, dynamic> json) {
    if (json.containsKey('text')) {
      return TextPart.fromJson(json);
    } else if (json.containsKey('media')) {
      return MediaPart.fromJson(json);
    } else if (json.containsKey('tool')) {
      return ToolPart.fromJson(json);
    } else {
      throw Exception('Unknown part type: $json');
    }
  }

  /// Converts this part to a JSON map.
  Map<String, dynamic> toJson();
}

/// A text part of a message's content.
class TextPart extends Part {
  /// Creates a [TextPart] with the given [text].
  const TextPart(this.text);

  /// Creates a [TextPart] from a JSON map.
  factory TextPart.fromJson(Map<String, dynamic> json) =>
      TextPart(json['text']);

  /// The text content of this part.
  final String text;

  @override
  Map<String, dynamic> toJson() => {'text': text};
}

/// A media part of a message's content, such as an image or video.
class MediaPart extends Part {
  /// Creates a [MediaPart] with the given [contentType] and [url].
  const MediaPart({this.contentType, this.url});

  /// Creates a [MediaPart] from a JSON map.
  factory MediaPart.fromJson(Map<String, dynamic> json) {
    final media = json['media'] as Map<String, dynamic>?;
    return MediaPart(contentType: media?['contentType'], url: media?['url']);
  }

  /// The MIME type of the media (e.g., 'image/jpeg').
  final String? contentType;

  /// The URL or data URI of the media.
  final String? url;

  @override
  Map<String, dynamic> toJson() => {
    'media': {'contentType': contentType, 'url': url},
  };
}

/// A tool call part of a message's content, representing a call to an external
/// tool or function.
class ToolPart extends Part {
  /// Creates a [ToolPart] with the given tool call details.
  const ToolPart({this.id, this.name, this.arguments, this.result});

  /// Creates a [ToolPart] from a JSON map.
  factory ToolPart.fromJson(Map<String, dynamic> json) {
    final tool = json['tool'] as Map<String, dynamic>?;
    return ToolPart(
      id: tool?['id'],
      name: tool?['name'],
      arguments: tool?['arguments'],
      result: tool?['result'],
    );
  }

  /// The unique identifier for the tool call.
  final String? id;

  /// The name of the tool being called.
  final String? name;

  /// The arguments passed to the tool.
  final dynamic arguments;

  /// The result returned from the tool call.
  final dynamic result;

  @override
  Map<String, dynamic> toJson() => {
    'tool': {'id': id, 'name': name, 'arguments': arguments, 'result': result},
  };
}
