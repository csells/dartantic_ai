---
title: Automatic Retry
---

# Automatic Retry

Built-in retry logic handles rate limits and temporary failures automatically.

## Zero Configuration

```dart
final agent = Agent('openai');

// Automatically retries on 429 errors
final result = await agent.send('Hello!');
```

## What Gets Retried

- **429 Rate Limits** - With exponential backoff
- **5xx Server Errors** - Temporary failures
- **Network Timeouts** - Connection issues
- **Retry-After Headers** - Respects server timing

## Timing Strategy

```
Attempt 1: Immediate
Attempt 2: 1s + jitter
Attempt 3: 2s + jitter  
Attempt 4: 4s + jitter
Max: 60 seconds
```

## Watch Retries

```dart
import 'package:logging/logging.dart';

// Enable logging
Logger.root.level = Level.ALL;
Logger.root.onRecord.listen((record) {
  print('[${record.loggerName}] ${record.message}');
});

// Make requests
final agent = Agent('openai');
await agent.send('Test');

// Example output:
// [RetryHttpClient] Request failed with 429, retrying in 1000ms (attempt 1/3)
// [RetryHttpClient] Request succeeded on attempt 2
```

## Provider Support

### Automatic Retry
- **OpenAI** - Full retry support
- **OpenRouter** - Provider-specific limits
- **Together AI** - High-throughput retry
- **Lambda** - Performance optimized
- **Ollama** - Local API stability

### SDK-Level Retry
- **Anthropic** - Built into SDK
- **Google** - Native retry logic
- **Mistral** - SDK handles retries
- **Cohere** - Provider-specific

## Handle Final Failures

```dart
try {
  final result = await agent.send('Generate report');
  print(result.output);
} on RateLimitException {
  print('Rate limit exceeded after retries');
  await Future.delayed(Duration(minutes: 1));
} on TimeoutException {
  print('Request timed out');
} catch (e) {
  print('Failed: $e');
}
```

## High-Volume Apps

```dart
// Spread requests over time
final results = <Future>[];

for (var i = 0; i < 100; i++) {
  results.add(
    Future.delayed(
      Duration(milliseconds: i * 100),
      () => agent.send('Request $i'),
    ),
  );
}

await Future.wait(results);
```

## Multi-Provider Fallback

```dart
// Try multiple providers
final providers = ['openai', 'anthropic', 'google'];

for (final provider in providers) {
  try {
    final agent = Agent(provider);
    return await agent.send(prompt);
  } catch (e) {
    continue; // Try next provider
  }
}
```

## Best Practices

1. **Let retry work** - Don't add manual retries
2. **Monitor patterns** - Use logging to track
3. **Spread load** - Space out batch requests
4. **Have fallbacks** - Use multiple providers

## Examples

- [Error handling](https://github.com/csells/darantic_ai/blob/main/packages/dartantic_ai/example/bin/chat.dart)
- [Multi-provider fallback](https://github.com/csells/darantic_ai/blob/main/packages/dartantic_ai/example/bin/multi_provider.dart)

## Next Steps

- [Error Handling](/error-handling) - Handle all error types
- [Usage Tracking](/usage-tracking) - Monitor retry costs
- [Providers](/providers) - Provider-specific limits
