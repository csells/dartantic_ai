---
title: "Agentic Behavior"
description: "What makes an agent an agent is the ability to chain multiple tool calls."
---

What makes an agent an agent is the ability to chain multiple tool calls to
solve more complex problems. The dartantic `Agent` calls your tools for you
automatically. You create an agent with a set of tools -- which themselves each
have a callback -- and the Agent will handle the tool calls from the model and
map them to the callbacks on your tools.

## Multi-Step Reasoning

As an example, here's an agent defined with two tools:

```dart
// Tools that work together
final tools = [
  Tool(
    name: 'get_current_time',
    description: 'Get the current date and time',
    onCall: (_) async => {'time': '2025-01-27T10:00:00Z'},
  ),
  Tool(
    name: 'find_events',
    description: 'Find events for a date',
    inputSchema: JsonSchema.object({
      'date': JsonSchema.string(),
    }),
    onCall: (args) async => {
      'events': ['Team Meeting at 11am', 'Lunch at 12pm'],
    },
  ),
];

// Agent chains tools automatically
final agent = Agent('openai', tools: tools);
final result = await agent.send(
  'What events do I have today? Find the current date first.'
);

// Agent will:
// 1. Call get_current_time → gets "2025-01-27"
// 2. Extract date from response
// 3. Call find_events with that date
// 4. Return final answer with events
```

We're asking the agent to call both two in succession here, one to find out the
current date and another to find the events associated with that date. That's
multiple round trips between the agent and the model, but the ultimate response
comes back from the model after it's done calling tools and has the data it
needs.

## Complex Workflows

Here's another example where we're configuring the agent with multiple tools
that the model can choose to call or not:

```dart
// Weather + activity planning
final tools = [
  weatherTool,    // Gets weather
  activityTool,   // Suggests activities based on weather
  bookingTool,    // Books the activity
];

final result = await agent.send(
  'Plan an outdoor activity for tomorrow in Seattle'
);
// Agent chains: weather → activity → booking
```

Here the agent calls the tools it decides it needs, potentially using the
results of one to form calls to another.

## Loop Behavior

Often we don't know how many tooling round-trips are going to happen, but the
`Agent` implementation will keep looping until the model is done calling tools
and provides its final response.

## Examples

- [Agent with
  tools](https://github.com/csells/dartantic_ai/blob/main/packages/dartantic_ai/example/bin/agent.dart)
- [Multi-tool
  calling](https://github.com/csells/dartantic_ai/blob/main/packages/dartantic_ai/example/bin/multi_tool_call.dart)

## Next Steps

- [Tool Calling](/tool-calling) - Define custom tools
- [Multi-turn Chat](/multi-turn-chat) - Maintain context
- [System Messages](/system-messages) - Guide agent behavior
- [Server-Side Tools](/server-side-tools) - Combine intrinsic and custom tools
